From HB Require Import structures.
From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat ssrint.
From mathcomp Require Import seq eqtype.

From GWP Require Import Equivalence.

HB.mixin Record isMonoid M of hasEq M := {
  law : M -> M -> M;
  e : M;
  associativity : forall x y z, law x (law y z) == law (law x y) z;
  neutral_left : forall x, law e x == x;
  neutral_right : forall x, law x e == x;
}.
#[short(type="monoid")]
HB.structure Definition Monoid := { G of isMonoid G & hasEq G }.
Infix "@" := law (at level 50).

HB.mixin Record isGroup G of hasEq G & isMonoid G := {
  inv : G -> G;

  inverse_left : forall x, x @ (inv x) == e;
  inverse_right : forall x, (inv x) @ x == e;
}.
#[short(type="group")]
HB.structure Definition Group := { G of isGroup G & hasEq G & isMonoid G }.

Definition power {G: group} (w: G) (k: int) : G :=
  match k with
  | Posz k => iter k (fun acc => acc @ w) e
  | Negz k => inv (iter k (fun acc => acc @ w) w) (* Negx 0 is -1 *)
  end.

(* If `l = [a; b; c; ...; z]`, `prod l = a @ b @ ... @ z` *)
Definition prod {M: monoid} (l: seq M) : M := foldr (fun y acc => y @ acc) e l.

Lemma prod0 {M: monoid} : @prod M nil = e.
Proof. done. Qed.

Lemma prod1s {M: monoid} (a: M) (l: seq M) : prod (a :: l) == a @ prod l.
Proof.
rewrite /prod /=.
reflexivity.
Qed.

#[short(type="deceqGroupType")]
HB.structure Definition DecEqGroup := { G of isGroup G & hasEq G & isMonoid G & hasDecEq G }.

(* Subgroup generated by a finite set of group elements *)
Section GeneratedSubgroup.

Variable G: deceqGroupType.
Variable generators: seq G.

Let generators_and_inverses := generators ++ (map inv generators).

Definition inSubgroup (x: G) :=
  exists (l: list G),
    (all (fun x => x \in generators_and_inverses) l) /\
    (x == prod l).

End GeneratedSubgroup.
Arguments inSubgroup {_}.
