From HB Require Import structures.
From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat ssrint.
From mathcomp Require Import seq eqtype fintype.
Require Import Setoid Morphisms.
From Stdlib Require List.

From GWP Require Import Equivalence.

HB.mixin Record isMonoid M of hasEq M := {
  law : M -> M -> M;
  e : M;
  associativity : forall x y z, law x (law y z) == law (law x y) z;
  neutral_left : forall x, law e x == x;
  neutral_right : forall x, law x e == x;
  congruent_left : forall x y z, y == z -> law x y == law x z;
  congruent_right : forall x y z, y == z -> law y x == law z x;
}.
#[short(type="monoid")]
HB.structure Definition Monoid := { G of isMonoid G & hasEq G }.
Infix "@" := law (at level 50).

HB.mixin Record isGroup G of hasEq G & isMonoid G := {
  inv : G -> G;

  inverse_left : forall x, x @ (inv x) == e;
  inverse_right : forall x, (inv x) @ x == e;
}.
#[short(type="group")]
HB.structure Definition Group := { G of isGroup G & hasEq G & isMonoid G }.

Definition power {G: group} (w: G) (k: int) : G :=
  match k with
  | Posz k => iter k (fun acc => acc @ w) e
  | Negz k => inv (iter k (fun acc => acc @ w) w) (* Negx 0 is -1 *)
  end.

(* If `l = [a; b; c; ...; z]`, `prod l = a @ b @ ... @ z` *)
Definition prod {M: monoid} (l: seq M) : M := foldr (fun y acc => y @ acc) e l.

Lemma prod0 {M: monoid} : @prod M nil = e.
Proof. done. Qed.

Lemma prod1s {M: monoid} (a: M) (l: seq M) : prod (a :: l) == a @ prod l.
Proof.
rewrite /prod /=.
reflexivity.
Qed.

Lemma prod_cat {M: monoid} (l1 l2: seq M): prod (l1 ++ l2) = (prod l1) @ (prod l2).
Admitted.

Global Instance : forall (G: group), Proper (eq ==> eq ==> eq) (law : G -> G -> G).
Proof.
move=> P a b eq_ab u v eq_uv.
transitivity (a @ v).
  exact: congruent_left.
exact: congruent_right.
Qed.

Lemma inv_involutive {G: group}: forall (g: G), inv (inv g) == g.
Proof.
move=> g.
have: (inv g) @ (inv (inv g)) == (inv g) @ g.
  by rewrite inverse_left inverse_right.
move=> /(congruent_left g).
by rewrite !associativity inverse_left !neutral_left.
Qed.

Lemma inv_proper {G: group}: forall (g g': G), g == g' -> inv g == inv g'.
Admitted.

#[short(type="deceqGroupType")]
HB.structure Definition DecEqGroup := { G of isGroup G & hasEq G & isMonoid G & hasDecEq G }.

HB.mixin Record isMorphism (G H: group) (f: G -> H) := {
  morphism_preserve_e: f e == e;
  morphism_preserve_law: forall x y, f (x @ y) == (f x) @ (f y);
  morphism_preserve_inv: forall x, f (inv x) == inv (f x);
}.
#[short(type="morphism")]
HB.structure Definition Morphism (G H: group) := { f of isMorphism G H f }.

HB.mixin Record isInjective (A B: equivType) (f: A -> B) := {
  injectivity_property: forall x y, f x == f y -> x == y;
}.

#[short(type="injectiveFunType")]
HB.structure Definition Injective (A B: equivType) := { f of isInjective A B f }.

#[short(type="injectiveMorphism")]
HB.structure Definition InjectiveMorphism (G H: group) := { f of isInjective G H f & isMorphism G H f }.

HB.mixin Record isSubgroup (G H: group) := {
  subgroup_inj: injectiveMorphism G H;
}.

#[short(type="subgroup")]
HB.structure Definition Subgroup (G: group) := { H of isSubgroup G H }.

(* Subgroup generated by a finite set of group elements *)
Section GeneratedSubgroup.

Variable G: deceqGroupType.
Variable generators: seq G.

Record generatedSubgroup: Type := {
  element_decomposition: seq G;
  decomposition_of_generators: List.Forall (fun el =>
    List.Exists (fun gen => gen == el \/ inv gen == el) generators
  ) element_decomposition;
}.

Definition gensubgroup_inj (x: generatedSubgroup): G := prod (element_decomposition x).

Definition gensubgroup_eq (x y: generatedSubgroup) := (gensubgroup_inj x) == (gensubgroup_inj y).
Lemma gensubgroup_eq_refl: forall x, gensubgroup_eq x x.
Proof. move=> x; rewrite /gensubgroup_eq; reflexivity. Qed.
Lemma gensubgroup_eq_sym: forall x y, gensubgroup_eq x y -> gensubgroup_eq y x.
Proof. move=> x y; rewrite /gensubgroup_eq; by symmetry. Qed.
Lemma gensubgroup_eq_trans: forall x y z, gensubgroup_eq x y -> gensubgroup_eq y z -> gensubgroup_eq x z.
Proof. move=> x y z; rewrite /gensubgroup_eq => ? ?; by transitivity (gensubgroup_inj y). Qed.

HB.instance Definition _ := hasEq.Build generatedSubgroup gensubgroup_eq gensubgroup_eq_refl gensubgroup_eq_sym gensubgroup_eq_trans.

Definition gensubgroup_law (x y : generatedSubgroup): generatedSubgroup.
Proof.
exists ((element_decomposition x) ++ (element_decomposition y)).
rewrite List.Forall_app; split; exact /decomposition_of_generators.
Defined.

Definition gensubgroup_neutral: generatedSubgroup.
Proof. exists [::]; exact: List.Forall_nil. Defined.

Lemma gensubgroup_associativity: forall (x y z: generatedSubgroup), gensubgroup_law x (gensubgroup_law y z) == gensubgroup_law (gensubgroup_law x y) z.
Proof. move=> x y z; by rewrite /gensubgroup_law/= /eq/= /gensubgroup_eq/= /gensubgroup_inj/= catA. Qed.

Lemma gensubgroup_neutral_left: forall (x: generatedSubgroup), gensubgroup_law gensubgroup_neutral x == x.
Proof. by rewrite /gensubgroup_law/= /eq/= /gensubgroup_eq/= /gensubgroup_inj/=. Qed.

Lemma gensubgroup_neutral_right: forall (x: generatedSubgroup), gensubgroup_law x gensubgroup_neutral == x.
Proof. move=> x; by rewrite /gensubgroup_law/= /eq/= /gensubgroup_eq/= /gensubgroup_inj/= cats0. Qed.

Lemma gensubgroup_congruent_left: forall (x y z: generatedSubgroup), y == z -> gensubgroup_law x y == gensubgroup_law x z.
Proof.
move=> x y z.
rewrite /gensubgroup_law/= /eq/= /gensubgroup_eq/= /gensubgroup_inj/= !prod_cat.
exact: congruent_left.
Qed.

Lemma gensubgroup_congruent_right: forall (x y z: generatedSubgroup), y == z -> gensubgroup_law y x == gensubgroup_law z x.
Proof.
move=> x y z.
rewrite /gensubgroup_law/= /eq/= /gensubgroup_eq/= /gensubgroup_inj/= !prod_cat.
exact: congruent_right.
Qed.

HB.instance Definition _ := isMonoid.Build generatedSubgroup gensubgroup_law gensubgroup_neutral gensubgroup_associativity gensubgroup_neutral_left gensubgroup_neutral_right gensubgroup_congruent_left gensubgroup_congruent_right.

Definition gensubgroup_inv: generatedSubgroup -> generatedSubgroup.
Proof.
move=> x.
exists (map inv (element_decomposition x)).
have := decomposition_of_generators x.
rewrite List.Forall_map; apply /List.Forall_impl => g.
apply /List.Exists_impl => g' [] ?; first by right; exact: inv_proper.
left; rewrite -[g']inv_involutive; exact: inv_proper.
Defined.

Lemma gensubgroup_inverse_left : forall x, x @ (gensubgroup_inv x) == e.
Proof.
move=> x.
rewrite /gensubgroup_inv/=/law/=/gensubgroup_law/=/eq/=/gensubgroup_eq/=/gensubgroup_inj/=.
Admitted.

Lemma gensubgroup_inverse_right : forall x, (gensubgroup_inv x) @ x == e.
Proof.
move=> x.
rewrite /gensubgroup_inv/=/law/=/gensubgroup_law/=/eq/=/gensubgroup_eq/=/gensubgroup_inj/=.
Admitted.

HB.instance Definition _ := isGroup.Build generatedSubgroup gensubgroup_inv gensubgroup_inverse_left gensubgroup_inverse_right.

Lemma gensubgroup_inj_injectivity: forall x y, x == y -> gensubgroup_inj x == gensubgroup_inj y.
Proof. move=> x y; by rewrite {1}/eq/=/gensubgroup_eq/=. Qed.

HB.instance Definition _ := isInjective.Build _ _ gensubgroup_inj gensubgroup_inj_injectivity.

Lemma gensubgroup_inj_preserve_e: gensubgroup_inj e == e.
Proof. by rewrite /gensubgroup_inj/=. Qed.
Lemma gensubgroup_inj_preserve_law: forall x y, gensubgroup_inj (law x y) == law (gensubgroup_inj x) (gensubgroup_inj y).
Proof. by move=> x y; rewrite /gensubgroup_inj/= prod_cat. Qed.
Lemma gensubgroup_inj_preserve_inv: forall x, gensubgroup_inj (inv x) == inv (gensubgroup_inj x).
Proof. move=> x; rewrite /gensubgroup_inj/=.
Admitted.

HB.instance Definition _ := isMorphism.Build _ _ gensubgroup_inj gensubgroup_inj_preserve_e gensubgroup_inj_preserve_law gensubgroup_inj_preserve_inv.

HB.instance Definition _ := isSubgroup.Build generatedSubgroup G gensubgroup_inj.

End GeneratedSubgroup.
Arguments generatedSubgroup {_}.
